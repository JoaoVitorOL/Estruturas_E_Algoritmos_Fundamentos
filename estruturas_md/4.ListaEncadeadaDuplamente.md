

# ğŸ“¦ Lista Duplamente Encadeada | Doubly Linked List (PT-BR)

![Lista dupla construÃ§Ã£o](../assets/duplaconstruir.png)


---

## ğŸ¯ FunÃ§Ã£o principal

A Lista Encadeada Duplamente Ã© uma estrutura de dados linear, dinÃ¢mica e nÃ£o contÃ­gua, caracterizada por:

- AlocaÃ§Ã£o dinÃ¢mica no Heap
- AusÃªncia de endereÃ§amento sequencial
- NavegaÃ§Ã£o bidirecional
- Encadeamento explÃ­cito por referÃªncias

Cada elemento (nÃ³) conhece:

- Quem vem antes
- Quem vem depois

Formalmente, a lista Ã© um grafo linear direcionado em duas direÃ§Ãµes, com restriÃ§Ãµes de borda.


<img width="2560" height="1440" alt="image" src="https://github.com/user-attachments/assets/f506b36d-c9a9-44f3-9603-5552b139922d" />

---

## ğŸ§  ONDE OS DADOS DE UMA LISTA ENCADEADA FICAM NA MEMÃ“RIA (JAVA)

> 1. Regra fundamental de memÃ³ria em Java
> - Objetos criados com 'new' ficam no HEAP
> - VariÃ¡veis locais e referÃªncias ficam na STACK
> - VariÃ¡veis de tipo objeto nÃ£o armazenam dados, apenas endereÃ§os

> 2. Estado inicial do programa: 
> A lista contÃ©m apenas uma referÃªncia para o primeiro nÃ³.

> 3. InserÃ§Ã£o de nÃ³s
> Cada 'new No(valor)' cria um objeto separado no heap.
> A lista aponta apenas para o primeiro.

> 4. Encadeamento: 
> Os nÃ³s se conectam por referÃªncias (proximo/anterior).
> NÃ£o existe armazenamento sequencial.

> 5. ExclusÃ£o: 
> Excluir remove referÃªncias, nÃ£o objetos imediatamente.
> O Garbage Collector limpa depois.

> 6. Conceito-chave
> Lista encadeada Ã© uma estrutura lÃ³gica baseada em referÃªncias.

---

# ğŸ§± Estrutura bÃ¡sica da lista

### ğŸ”¹ NÃ³ (classe `No`)

Cada nÃ³ encapsula **trÃªs informaÃ§Ãµes**:

- `valor` â†’ dado armazenado
- `proximo` â†’ referÃªncia para o prÃ³ximo nÃ³
- `anterior` â†’ referÃªncia para o nÃ³ anterior

RepresentaÃ§Ã£o conceitual:

```text
[ anterior | valor | proximo ]
````
Aspectos tÃ©cnicos:

- valor representa informaÃ§Ã£o.
- proximo e anterior representam ligaÃ§Ãµes estruturais, nÃ£o dados.
- A lista Ã© construÃ­da exclusivamente por essas referÃªncias.


# ğŸ§  Conceito central: relacionamento bidirecional

RepresentaÃ§Ã£o de uma lista duplamente encadeada:
```text
null â† [10] â‡„ [20] â‡„ [30] â†’ null
````
CondiÃ§Ãµes de borda:
- Primeiro nÃ³: anterior == null
- Ãšltimo nÃ³: proximo == null

# ğŸ—£ï¸ CabeÃ§as da lista

O cÃ³digo mantÃ©m duas referÃªncias externas:
```java
private No primeiro;
private No ultimo;
````

FunÃ§Ãµes:
primeiro â†’ ponto de entrada da lista
ultimo â†’ ponto de saÃ­da da lista

ObservaÃ§Ã£o crÃ­tica:
> "primeiro" e "ultimo" nÃ£o sÃ£o nÃ³s, apenas referÃªncias.

# â• Inserir no inÃ­cio

![Lista dupla inserir](../assets/duplainseririnicio.png)


## Objetivo
Inserir um novo nÃ³ antes do atual primeiro.

## ExecuÃ§Ã£o lÃ³gica

1. Criar o novo nÃ³

2. Se a lista estiver vazia:
   - ultimo tambÃ©m aponta para o novo nÃ³ <br>
   
Caso contrÃ¡rio:

   - O antigo primeiro aponta de volta para o novo
   - O novo aponta para o antigo primeiro

3. Atualizar primeiro

Fluxo estrutural:
```text
novo â‡„ antigoPrimeiro
primeiro(Head) â†’ novo
````


# â• Inserir no final

![Lista dupla inserir](../assets/duplainserirfinal.png)

## Objetivo
Adicionar um novo nÃ³ apÃ³s o atual ultimo.

## ExecuÃ§Ã£o lÃ³gica

1. Criar novo nÃ³

2. Se lista vazia:
   - primeiro aponta para ele <br>

Caso contrÃ¡rio:
  - Antigo Ãºltimo aponta para o novo
  - Novo aponta de volta para o antigo Ãºltimo

3. Atualizar ultimo

# â– Excluir do inÃ­cio
![Lista dupla excluir inicio](../assets/duplaexcluirinicio.png)

## Objetivo
Remover o nÃ³ apontado por primeiro (Head).

## ExecuÃ§Ã£o lÃ³gica

1. Guardar o nÃ³ removido

2. Se havia apenas um nÃ³:
   - ultimo = null <br>

Caso contrÃ¡rio:
   - O segundo nÃ³ perde referÃªncia para trÃ¡s

4. Atualizar "primeiro"

5. Isolar o nÃ³ removido

Conceito importante
> O nÃ³ nÃ£o Ã© apagado â€” ele apenas perde as referÃªncias da lista.

# â– Excluir do final

![Lista dupla excluir final](../assets/duplaexcluirfinal.png)

## Objetivo

Remover o nÃ³ apontado por ultimo (tail).

## ExecuÃ§Ã£o lÃ³gica

1. Guardar o nÃ³ removido

2. Se havia apenas um nÃ³:
   - primeiro = null <br>

Caso contrÃ¡rio:
  - O penÃºltimo perde referÃªncia para frente

3. Atualizar ultimo

4. Isolar o nÃ³ removido

# âŒ Excluir qualquer valor
![Lista dupla excluir qualquer](../assets/duplaexcluirqualquer.png)

## Objetivo
Remover um nÃ³ intermediÃ¡rio sem necessidade de ponteiro auxiliar externo.


1. Percorrer a lista atÃ© encontrar o valor

2. Caso nÃ£o encontre, retornar null

3. Se for o primeiro:
   - Atualizar primeiro <br>

Caso contrÃ¡rio:
  - Ligar anterior ao proximo

4. Se for o Ãºltimo:
   - Atualizar ultimo <br>

Caso contrÃ¡rio: 
   - Ajustar o anterior do prÃ³ximo nÃ³

5. Isolar o nÃ³ removido

Vantagem estrutural
> O prÃ³prio nÃ³ conhece quem vem antes e depois.

# ğŸ” Mostrar do inÃ­cio

![Lista dupla](../assets/listadupla.png)

Percorre a lista usando "proximo".

## ğŸ” Mostrar do final
Percorre a lista usando "anterior".


# ğŸ” Pesquisar valor

Funcionamento:

- Percorre a lista do inÃ­cio

- Compara valores

- Retorna o nÃ³ ou null

ObservaÃ§Ã£o:
Mesmo com lista dupla, a busca continua sequencial.

---

# ğŸ‘ï¸  ESQUEMA VISUAL â€” LISTA DUPLAMENTE ENCADEADA NA MEMÃ“RIA (JAVA)

CRIAÃ‡ÃƒO DA LISTA <br>

CÃ³digo: <br>

ListaEncadeadaDuplamente lista = new ListaEncadeadaDuplamente(); <br>

Stack: <br>

lista â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º referÃªncia 0x100 <br>

Heap: <br>

0x100 â†’ ListaEncadeadaDuplamente { <br>
primeiro = null <br>
ultimo = null <br>
} <br>

lista.inserirInicio((short) 10) <br>

Stack: <br>

lista â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º 0x100 <br>

Heap: <br>

0x100 â†’ ListaEncadeadaDuplamente { <br>
primeiro â”€â”€â”€â”€â”€â”€â”€â–º 0x200 <br>
ultimo â”€â”€â”€â”€â”€â”€â”€â–º 0x200 <br>
} <br>

0x200 â†’ No { <br>
valor = 10 <br>
anterior = null <br>
proximo = null <br>
} <br>

OBS: <br>

Primeiro e Ãºltimo apontam para o mesmo nÃ³. <br>
Lista com apenas um elemento. <br>

lista.inserirInicio((short) 20) <br>

Stack: <br>

lista â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º 0x100 <br>

Heap: <br>

0x100 â†’ ListaEncadeadaDuplamente { <br>
primeiro â”€â”€â”€â”€â”€â”€â”€â–º 0x300 <br>
ultimo â”€â”€â”€â”€â”€â”€â”€â–º 0x200 <br>
} <br>

0x300 â†’ No { <br>
valor = 20 <br>
anterior = null <br>
proximo â”€â”€â”€â”€â”€â”€â”€â–º 0x200 <br>
} <br>

0x200 â†’ No { <br>
valor = 10 <br>
anterior â”€â”€â”€â”€â”€â”€â”€â–º 0x300 <br>
proximo = null <br>
} <br>

lista.inserirFinal((short) 30) <br>

Stack: <br>

lista â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º 0x100 <br>

Heap: <br>

0x100 â†’ ListaEncadeadaDuplamente { <br>
primeiro â”€â”€â”€â”€â”€â”€â”€â–º 0x300 <br>
ultimo â”€â”€â”€â”€â”€â”€â”€â–º 0x400 <br>
} <br>

0x300 â†’ No { <br>
valor = 20 <br>
anterior = null <br>
proximo â”€â”€â”€â”€â”€â”€â”€â–º 0x200 <br>
} <br>

0x200 â†’ No { <br>
valor = 10 <br>
anterior â”€â”€â”€â”€â”€â”€â”€â–º 0x300 <br>
proximo â”€â”€â”€â”€â”€â”€â”€â–º 0x400 <br>
} <br>

0x400 â†’ No { <br>
valor = 30 <br>
anterior â”€â”€â”€â”€â”€â”€â”€â–º 0x200 <br>
proximo = null <br>
} <br>

VISÃƒO LÃ“GICA: <br>

null â† [20] â‡„ [10] â‡„ [30] â†’ null <br>

lista.excluirInicio() <br>

ANTES: <br>

primeiro â”€â–º 0x300 â‡„ 0x200 â‡„ 0x400 <br>

DEPOIS: <br>

Stack: <br>

lista â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º 0x100 <br>

Heap: <br>

0x100 â†’ ListaEncadeadaDuplamente { <br>
primeiro â”€â”€â”€â”€â”€â”€â”€â–º 0x200 <br>
ultimo â”€â”€â”€â”€â”€â”€â”€â–º 0x400 <br>
} <br>

0x300 â†’ No { <br>
valor = 20 <br>
anterior = null <br>
proximo = null (NÃ“ DESCONECTADO) <br>
} <br>

0x200 â†’ No { <br>
valor = 10 <br>
anterior = null <br>
proximo â”€â”€â”€â”€â”€â”€â”€â–º 0x400 <br>
} <br>

0x400 â†’ No { <br>
valor = 30 <br>
anterior â”€â”€â”€â”€â”€â”€â”€â–º 0x200 <br>
proximo = null <br>
} <br>

OBS: <br>

O nÃ³ 0x300 foi removido da lista. <br>
Ele continua no heap, mas estÃ¡ isolado. <br>
Se nÃ£o houver mais referÃªncias, o Garbage Collector poderÃ¡ removÃª-lo. <br>

lista.excluirFinal() <br>

ANTES: <br>

primeiro â”€â–º 0x200 â‡„ 0x400 <br>

DEPOIS: <br>

Stack: <br>

lista â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º 0x100 <br>

Heap: <br>

0x100 â†’ ListaEncadeadaDuplamente { <br>
primeiro â”€â”€â”€â”€â”€â”€â”€â–º 0x200 <br>
ultimo â”€â”€â”€â”€â”€â”€â”€â–º 0x200 <br>
} <br>

0x400 â†’ No { <br>
valor = 30 <br>
anterior = null <br>
proximo = null (NÃ“ DESCONECTADO) <br>
} <br>

0x200 â†’ No { <br>
valor = 10 <br>
anterior = null <br>
proximo = null <br>
} <br>

CONCEITOS-CHAVE <br>

A lista NÃƒO contÃ©m os nÃ³s fisicamente. <br>

A lista mantÃ©m apenas DUAS referÃªncias: <br>

primeiro <br>

ultimo <br>

Cada nÃ³ contÃ©m: <br>

um valor <br>

uma referÃªncia para o prÃ³ximo <br>

uma referÃªncia para o anterior <br>

A ordem da lista Ã© definida exclusivamente pelas referÃªncias. <br>

Os nÃ³s estÃ£o espalhados no heap, nÃ£o em posiÃ§Ãµes contÃ­guas. <br>


---

## ğŸ”— RelaÃ§Ã£o com outras estruturas

A lista duplamente encadeada Ã© base direta para:

- Deques

- LRU Cache

- NavegaÃ§Ã£o undo/redo

- Gerenciadores de histÃ³rico

- Estruturas de sistemas operacionais



